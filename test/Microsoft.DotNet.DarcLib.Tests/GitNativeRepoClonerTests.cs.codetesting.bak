// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.DotNet;
using Microsoft.DotNet.DarcLib;
using Microsoft.DotNet.DarcLib.Helpers;
using Microsoft.Extensions;
using Microsoft.Extensions.Logging;
using Moq;
using NUnit.Framework;

namespace Microsoft.DotNet.DarcLib.Tests;

public class GitNativeRepoClonerTests
{
    private static ProcessExecutionResult CreateResult(int exitCode)
    {
        return new ProcessExecutionResult
        {
            ExitCode = exitCode,
            TimedOut = false,
            StandardError = string.Empty,
            StandardOutput = string.Empty
        };
    }

    /// <summary>
    /// Verifies that CloneNoCheckoutAsync always triggers a clone with the '--no-checkout' flag
    /// and does not perform a subsequent 'git checkout' step, regardless of whether gitDirectory is provided.
    /// Inputs:
    ///  - repoUri: a sample repository URI.
    ///  - targetDirectory: a sample target directory for the clone.
    ///  - gitDirectory: null to omit the --git-dir argument, or a non-null path to include it.
    /// Expected:
    ///  - IProcessManager.ExecuteGit is called once for the clone with arguments including '--no-checkout' and not '--recurse-submodules'.
    ///  - IProcessManager.ExecuteGit is called once for 'config core.longpaths true'.
    ///  - IProcessManager.ExecuteGit is never called with 'checkout' since commit is null for CloneNoCheckoutAsync.
    /// </summary>
    [TestCase(null)]
    [TestCase("C:\\temp\\.git")]
    [Author("Code Testing Agent v0.3.0-alpha.25425.8+159f94d")]
    [Category("auto-generated")]
    public async Task CloneNoCheckoutAsync_GitDirectoryVariants_DisablesCheckoutAndInvokesConfig(string gitDirectory)
    {
        // Arrange
        var repoUri = "https://example.com/repo.git";
        var targetDirectory = "C:\\work\\repo";

        var gitClientMock = new Mock<ILocalGitClient>(MockBehavior.Strict);
        gitClientMock
            .Setup(m => m.AddGitAuthHeader(
                It.IsAny<IList<string>>(),
                It.IsAny<IDictionary<string, string>>(),
                It.IsAny<string>()))
            .Returns(Task.CompletedTask);

        var processManagerMock = new Mock<IProcessManager>(MockBehavior.Strict);

        processManagerMock
            .Setup(m => m.ExecuteGit(
                It.Is<string>(wd => wd == Environment.CurrentDirectory),
                It.Is<IEnumerable<string>>(a =>
                    a.Contains("clone") &&
                    a.Contains("-q") &&
                    a.Contains("--no-checkout") &&
                    !a.Contains("--recurse-submodules") &&
                    a.Contains(repoUri) &&
                    a.Contains(targetDirectory) &&
                    (gitDirectory == null
                        ? !a.Contains("--git-dir")
                        : a.Contains("--git-dir") && a.Contains(gitDirectory))),
                It.IsAny<Dictionary<string, string>>(),
                It.IsAny<CancellationToken>()))
            .ReturnsAsync(new ProcessExecutionResult { ExitCode = 0 });

        processManagerMock
            .Setup(m => m.ExecuteGit(
                It.Is<string>(wd => wd == targetDirectory),
                It.Is<string[]>(args => args.Length == 3 && args[0] == "config" && args[1] == "core.longpaths" && args[2] == "true")))
            .ReturnsAsync(new ProcessExecutionResult { ExitCode = 0 });

        var loggerMock = new Mock<ILogger>(MockBehavior.Loose);
        var sut = new GitNativeRepoCloner(gitClientMock.Object, processManagerMock.Object, loggerMock.Object);

        // Act
        await sut.CloneNoCheckoutAsync(repoUri, targetDirectory, gitDirectory);

        // Assert
        processManagerMock.Verify(m => m.ExecuteGit(
            Environment.CurrentDirectory,
            It.Is<IEnumerable<string>>(a =>
                a.Contains("clone") &&
                a.Contains("-q") &&
                a.Contains("--no-checkout") &&
                !a.Contains("--recurse-submodules") &&
                a.Contains(repoUri) &&
                a.Contains(targetDirectory) &&
                (gitDirectory == null
                    ? !a.Contains("--git-dir")
                    : a.Contains("--git-dir") && a.Contains(gitDirectory))),
            It.IsAny<Dictionary<string, string>>(),
            It.IsAny<CancellationToken>()),
            Times.Once);

        processManagerMock.Verify(m => m.ExecuteGit(
            It.Is<string>(wd => wd == targetDirectory),
            It.Is<string[]>(args => args.Length == 3 && args[0] == "config" && args[1] == "core.longpaths" && args[2] == "true")),
            Times.Once);

        processManagerMock.Verify(m => m.ExecuteGit(
            It.Is<string>(wd => wd == targetDirectory),
            It.Is<string[]>(args => args.Length >= 1 && args[0] == "checkout")),
            Times.Never);

        gitClientMock.Verify(m => m.AddGitAuthHeader(
            It.IsAny<IList<string>>(),
            It.IsAny<IDictionary<string, string>>(),
            It.Is<string>(u => u == repoUri)),
            Times.Once);
    }

}
